<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\Precise;

class alpaca extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'alpaca',
            'name' => 'Alpaca',
            'countries' => array( 'US' ),
            'rateLimit' => 300, // 200 calls per min --> 300 ms between calls
            'hostname' => 'alpaca.markets',
            'urls' => array(
                'logo' => 'https://user-images.githubusercontent.com/26471228/142237130-8f3a06c5-7e35-4fa1-9a82-28ac25795490.jpg',
                'www' => 'https://alpaca.markets',
                'api' => array(
                    'public' => 'https://api.alpaca.markets/{version}',
                    'private' => 'https://api.alpaca.markets/{version}',
                    'cryptoPrivate' => 'https://data.alpaca.markets/{version}',
                ),
                'test' => array(
                    'public' => 'https://paper-api.alpaca.markets/{version}',
                    'private' => 'https://paper-api.alpaca.markets/{version}',
                    'cryptoPrivate' => 'https://data.alpaca.markets/{version}',
                ),
                'doc' => 'https://alpaca.markets/docs/',
                'fees' => 'https://alpaca.markets/support/what-are-the-fees-associated-with-crypto-trading/',
            ),
            'has' => array(
                'CORS' => null,
                'spot' => true,
                'margin' => null,
                'swap' => null,
                'future' => null,
                'option' => null,
                'cancelOrder' => true,
                'createOrder' => true,
                'fetchBalance' => 'emulated',
                'fetchMarkets' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => 'emulated',
                'fetchTicker' => true,
                'fetchTrades' => true,
            ),
            'api' => array(
                'public' => array(
                ),
                'private' => array(
                    'get' => array(
                        'assets',
                        'account',
                        'orders',
                        'orders/{order_id}',
                        'positions',
                        'positions/{symbol}',
                        'account/activities/{activity_type}',
                    ),
                    'post' => array(
                        'orders',
                    ),
                    'delete' => array(
                        'orders',
                        'orders/{order_id}',
                    ),
                ),
                'cryptoPrivate' => array(
                    'get' => array(
                        'crypto/{symbol}/quotes/latest',
                        'crypto/{symbol}/trades/latest',
                        'crypto/{symbol}/xbbo/latest',
                        'crypto/{symbol}/trades',
                    ),
                ),
            ),
            'requiredCredentials' => array(
                'apiKey' => true,
                'secret' => true,
            ),
            'options' => array(
                'versions' => array(
                    'public' => 'v2',
                    'private' => 'v2',
                    'cryptoPrivate' => 'v1beta1', // crypto beta
                ),
                'defaultExchange' => 'CBSE',
                'exchanges' => array(
                    'CBSE', // Coinbase
                    'FTX',
                    'GNSS', // Genesis
                    'ERSX', // ErisX
                ),
                'defaultTimeInForce' => 'day', // fok, gtc, ioc
                'clientOrderId' => 'ccxt_{id}',
            ),
            'exceptions' => array(
                'exact' => array(
                    'buying power or shares is not sufficient.' => '\\ccxt\\InsufficientFunds',
                    'order is not found' => '\\ccxt\\OrderNotFound',
                    'failed to cancel order' => '\\ccxt\\InvalidOrder',
                    'the order is not cancelable' => '\\ccxt\\InvalidOrder',
                    'position is not found' => '\\ccxt\\BadRequest',
                    'Failed to liquidate' => '\\ccxt\\InvalidOrder',
                    'position does not exist' => '\\ccxt\\BadRequest',
                ),
                'broad' => array(
                    'input parameters are not recognized' => '\\ccxt\\BadRequest',
                    'invalid query parameters' => '\\ccxt\\BadRequest',
                    'unauthorized' => '\\ccxt\\PermissionDenied',
                    'too many requests' => '\\ccxt\\RateLimitExceeded',
                    'not found' => '\\ccxt\\BadSymbol',
                    'request is not authorized' => '\\ccxt\\PermissionDenied',
                    'forbidden' => '\\ccxt\\PermissionDenied',
                ),
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        $request = array(
            'asset_class' => 'crypto',
            'tradeable' => true,
        );
        $assets = yield $this->privateGetAssets (array_merge($request, $params));
        // {
        //     "id" => "904837e3-3b76-47ec-b432-046db621571b",
        //     "class" => "us_equity",
        //     "exchange" => "NASDAQ",
        //     "symbol" => "AAPL",
        //     "status" => "active",
        //     "tradable" => true,
        //     "marginable" => true,
        //     "shortable" => true,
        //     "easy_to_borrow" => true,
        //     "fractionable" => true
        //   }
        $ids = array();
        for ($i = 0; $i < count($assets); $i++) {
            $ids[] = $assets[$i]['symbol'];
        }
        $markets = array();
        for ($i = 0; $i < count($ids); $i++) {
            $id = $ids[$i];
            // will need to change if $base or $quote currency ticker` length changes
            $base = strtoupper(mb_substr($id, 0, 3 - 0));
            $quote = strtoupper(mb_substr($id, 3, 6 - 3));
            $symbol = $base . '/' . $quote;
            $baseId = strtolower($base);
            $quoteId = strtolower($quote);
            $active = true;
            $taker = 0;
            $maker = 0;
            $percentage = false;
            $tierBased = false;
            $feeSide = null;
            $precision = array(
                'price' => null,
                'amount' => null,
                'cost' => null,
            );
            $info = null;
            $spot = true;
            $markets[] = array(
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'active' => $active,
                'taker' => $taker,
                'maker' => $maker,
                'tierBased' => $percentage,
                'percentage' => $tierBased,
                'feeSide' => $feeSide,
                'type' => 'spot',
                'spot' => $spot,
                'precision' => $precision,
                'limits' => array(
                    'amount' => array(
                        'min' => null,
                        'max' => null,
                    ),
                ),
                'info' => $info,
            );
        }
        return $markets;
    }

    public function fetch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $id = $market['id'];
        $request = array(
            'symbol' => $id,
        );
        // specify exchange to avoid bidPrice > askPrice --- interexchange arbitrage opportunities
        // needed to add to pass orderbook test => assert (bids[0][0] <= asks[0][0])
        if (!(is_array($params) && array_key_exists('exchanges', $params))) {
            $params['exchanges'] = $this->safe_string($this->options, 'defaultExchange');
        }
        $response = yield $this->cryptoPrivateGetCryptoSymbolXbboLatest (array_merge($request, $params));
        // {
        //     "symbol" => "BTCUSD",
        //     "xbbo" => {
        //     "t" => "2021-11-16T22:16:00.468860416Z",
        //     "ax" => "FTX",
        //     "ap" => 60564,
        //     "as" => 0.36,
        //     "bx" => "FTX",
        //     "bp" => 60555,
        //     "bs" => 0.36
        // }
        $ticker = $this->safe_value($response, 'xbbo', array());
        return $this->parse_ticker($ticker, $market);
    }

    public function fetch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $id = $market['id'];
        $request = array(
            'symbol' => $id,
        );
        if ($since !== null) {
            $request['start'] = $this->iso8601($since);
        } else {
            $request['start'] = $this->iso8601($this->milliseconds());
        }
        if ($limit !== null) {
            // hack to parse $limit as integer
            $request['limit'] = $this->safe_integer(array( 'limit' => $limit ), 'limit');
        }
        $response = yield $this->cryptoPrivateGetCryptoSymbolTrades (array_merge($request, $params));
        // {
        //     "symbol" => "BTCUSD",
        //     "trades" => [
        //          array(
        //          "t" => "2021-11-17T00:18:02.530806Z",
        //          "x" => "CBSE",
        //          "p" => 60011.36,
        //          "s" => 0.00956419,
        //          "tks" => "S",
        //          "i" => 237168320
        //          ),
        // }
        $trades = $this->safe_value($response, 'trades', array());
        return $this->parse_trades($trades, $market, $since, $limit);
    }

    public function fetch_order_book($symbol, $limit = null, $params = array ()) {
        // Alpaca does not support level 2 depth $orderbook
        // We emulate fetchOrderbook with single BBO
        yield $this->load_markets();
        $market = $this->market($symbol);
        $id = $market['id'];
        $request = array(
            'symbol' => $id,
        );
        // specify exchange to avoid bidPrice > askPrice --- interexchange arbitrage opportunities
        // needed to add to pass $orderbook test => assert (bids[0][0] <= asks[0][0])
        if (!(is_array($params) && array_key_exists('exchanges', $params))) {
            $params['exchanges'] = $this->safe_string($this->options, 'defaultExchange');
        }
        $response = yield $this->cryptoPrivateGetCryptoSymbolXbboLatest (array_merge($request, $params));
        // {
        //     "symbol" => "BTCUSD",
        //     "xbbo" => {
        //     "t" => "2021-11-16T22:16:00.468860416Z",
        //     "ax" => "FTX",
        //     "ap" => 60564,
        //     "as" => 0.36,
        //     "bx" => "FTX",
        //     "bp" => 60555,
        //     "bs" => 0.36
        // }
        $quote = $this->safe_value($response, 'xbbo', array());
        $shallow_bid = array( $this->safe_number($quote, 'bp'), $this->safe_number($quote, 'bs') );
        $shallow_ask = array( $this->safe_number($quote, 'ap'), $this->safe_number($quote, 'as') );
        $timestamp = $this->milliseconds(); // parseDate ($this->safe_string($quote, 't'));
        $orderbook = array(
            'bids' => array( $shallow_bid ),
            'asks' => array( $shallow_ask ),
        );
        return $this->parse_order_book($orderbook, $symbol, $timestamp);
    }

    public function fetch_balance($params = array ()) {
        yield $this->load_markets();
        $free = array();
        $used = array();
        $total = array();
        $currencies = array();
        $accountResponse = yield $this->privateGetAccount ();
        // {
        //     "account_blocked" => false,
        //     "account_number" => "010203ABCD",
        //     "buying_power" => "262113.632",
        //     "cash" => "-23140.2",
        //     "created_at" => "2019-06-12T22:47:07.99658Z",
        //     "currency" => "USD",
        //     "daytrade_count" => 0,
        //     "daytrading_buying_power" => "262113.632",
        //     "equity" => "103820.56",
        //     "id" => "e6fe16f3-64a4-4921-8928-cadf02f92f98",
        //     "initial_margin" => "63480.38",
        //     "last_equity" => "103529.24",
        //     "last_maintenance_margin" => "38000.832",
        //     "long_market_value" => "126960.76",
        //     "maintenance_margin" => "38088.228",
        //     "multiplier" => "4",
        //     "pattern_day_trader" => false,
        //     "portfolio_value" => "103820.56",
        //     "regt_buying_power" => "80680.36",
        //     "short_market_value" => "0",
        //     "shorting_enabled" => true,
        //     "sma" => "0",
        //     "status" => "ACTIVE",
        //     "trade_suspended_by_user" => false,
        //     "trading_blocked" => false,
        //     "transfers_blocked" => false
        // }
        $accountCurrency = $this->safe_string($accountResponse, 'currency');
        $accountCurrencyFree = $this->safe_string($accountResponse, 'cash');
        $free[$accountCurrency] = $accountCurrencyFree;
        $used[$accountCurrency] = 0;
        $total[$accountCurrency] = $accountCurrencyFree;
        $currencies[$accountCurrency] = array( 'free' => $accountCurrencyFree, 'used' => 0, 'total' => $accountCurrencyFree );
        // initialize $currencies
        $symbols = $this->symbols;
        for ($i = 0; $i < count($symbols); $i++) {
            $market = $this->market($symbols[$i]);
            $base = $this->safe_string($market, 'base');
            $free[$base] = 0;
            $used[$base] = 0;
            $total[$base] = 0;
            $currencies[$base] = array( 'free' => 0, 'used' => 0, 'total' => 0 );
        }
        // fill in existing $positions
        $positions = yield $this->privateGetPositions ();
        // array(
        //     {
        //         "asset_id" => "ef145fe0-95cd-453a-8609-db7200ff0279",
        //         "symbol" => "BTCUSD",
        //         "exchange" => "crypto",
        //         "asset_class" => "crypto",
        //         "asset_marginable" => false,
        //         "qty" => "0.0167",
        //         "avg_entry_price" => "59506.1",
        //         "side" => "long",
        //         "market_value" => "988.423067",
        //         "cost_basis" => "993.75187",
        //         "unrealized_pl" => "-5.328803",
        //         "unrealized_plpc" => "-0.0053623073936958",
        //         "unrealized_intraday_pl" => "-5.328803",
        //         "unrealized_intraday_plpc" => "-0.0053623073936958",
        //         "current_price" => "59187.01",
        //         "lastday_price" => "59440.5",
        //         "change_today" => "-0.004264600735189"
        //     }
        // )
        for ($i = 0; $i < count($positions); $i++) {
            $position = $positions[$i];
            if ($this->safe_string($position, 'asset_class') === 'crypto') {
                $id = $this->safe_string($position, 'symbol');
                $market = $this->markets_by_id[$id];
                $base = $this->safe_string($market, 'base');
                $amount = $this->safe_number($position, 'qty');
                $free[$base] = $amount;
                $used[$base] = 0;
                $total[$base] = $amount;
                $currencies[$base] = array( 'free' => $amount, 'used' => 0, 'total' => $amount );
            }
        }
        $timestamp = $this->milliseconds(); // alpaca doesn't provide timestamps with account/positions data
        $balance = array(
            'info' => null,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
        $balance = array_merge($balance, $free, $used, $total, $currencies);
        return $this->safe_balance($balance);
    }

    public function create_order($symbol, $type, $side, $amount, $price = null, $params = array ()) {
        yield $this->load_markets();
        $market = $this->market($symbol);
        $id = $market['id'];
        $request = array(
            'symbol' => $id,
            'qty' => $amount,
            'side' => $side,
            'type' => $type,
        );
        if ($type === 'limit') {
            $request['limit_price'] = $price;
        }
        if (!(is_array($params) && array_key_exists('timeInForce', $params))) {
            $request['time_in_force'] = $this->safe_string($this->options, 'defaultTimeInForce');
        }
        $clientOrderId = $this->safe_string($this->options, 'clientOrderId');
        $uuid = $this->uuid();
        $parts = explode('-', $uuid);
        $random_id = implode('', $parts);
        $request['client_order_id'] = $this->implode_params($clientOrderId, array( 'id' => $random_id ));
        $order = yield $this->privatePostOrders (array_merge($request, $params));
        // {
        // "id" => "61e69015-8549-4bfd-b9c3-01e75843f47d",
        // "client_order_id" => "eb9e2aaa-f71a-4f51-b5b4-52a6c565dad4",
        // "created_at" => "2021-03-16T18:38:01.942282Z",
        // "updated_at" => "2021-03-16T18:38:01.942282Z",
        // "submitted_at" => "2021-03-16T18:38:01.937734Z",
        // "filled_at" => null,
        // "expired_at" => null,
        // "canceled_at" => null,
        // "failed_at" => null,
        // "replaced_at" => null,
        // "replaced_by" => null,
        // "replaces" => null,
        // "asset_id" => "b0b6dd9d-8b9b-48a9-ba46-b9d54906e415",
        // "symbol" => "AAPL",
        // "asset_class" => "us_equity",
        // "notional" => "500",
        // "qty" => null,
        // "filled_qty" => "0",
        // "filled_avg_price" => null,
        // "order_class" => "",
        // "order_type" => "market",
        // "type" => "market",
        // "side" => "buy",
        // "time_in_force" => "day",
        // "limit_price" => null,
        // "stop_price" => null,
        // "status" => "accepted",
        // "extended_hours" => false,
        // "legs" => null,
        // "trail_percent" => null,
        // "trail_price" => null,
        // "hwm" => null
        // }
        return $this->parse_order($order, $market);
    }

    public function cancel_order($id, $symbol = null, $params = array ()) {
        // cancelling order by $symbol not yet supported
        $request = array(
            'order_id' => $id,
        );
        $response = yield $this->privateDeleteOrdersOrderId (array_merge($request, $params));
        // {
        //     "code" => 40410000,
        //     "message" => "order is not found."
        // }
        return $this->safe_value($response, 'message', array());
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        // fetching $order by $symbol not yet supported
        yield $this->load_markets();
        $request = array(
            'order_id' => $id,
        );
        $order = yield $this->privateGetOrdersOrderId (array_merge($request, $params));
        // {
        //     "id" => "61e69015-8549-4bfd-b9c3-01e75843f47d",
        //     "client_order_id" => "eb9e2aaa-f71a-4f51-b5b4-52a6c565dad4",
        //     "created_at" => "2021-03-16T18:38:01.942282Z",
        //     "updated_at" => "2021-03-16T18:38:01.942282Z",
        //     "submitted_at" => "2021-03-16T18:38:01.937734Z",
        //     "filled_at" => null,
        //     "expired_at" => null,
        //     "canceled_at" => null,
        //     "failed_at" => null,
        //     "replaced_at" => null,
        //     "replaced_by" => null,
        //     "replaces" => null,
        //     "asset_id" => "b0b6dd9d-8b9b-48a9-ba46-b9d54906e415",
        //     "symbol" => "AAPL",
        //     "asset_class" => "us_equity",
        //     "notional" => "500",
        //     "qty" => null,
        //     "filled_qty" => "0",
        //     "filled_avg_price" => null,
        //     "order_class" => "",
        //     "order_type" => "market",
        //     "type" => "market",
        //     "side" => "buy",
        //     "time_in_force" => "day",
        //     "limit_price" => null,
        //     "stop_price" => null,
        //     "status" => "accepted",
        //     "extended_hours" => false,
        //     "legs" => null,
        //     "trail_percent" => null,
        //     "trail_price" => null,
        //     "hwm" => null
        // }
        $_id = $this->safe_string($order, 'symbol');
        $market = $this->safe_string($this->markets_by_id, $_id);
        return $this->parse_order($order, $market);
    }

    public function fetch_open_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        // $symbol, $since, and $limit filtering done by base class
        yield $this->load_markets();
        // returns open orders by default
        $_orders = yield $this->privateGetOrders ($params);
        // add symbols to orders to handle parseOrders
        $ordersWithSymbols = array();
        for ($i = 0; $i < count($_orders); $i++) {
            $order = $_orders[$i];
            $market = $this->safe_string($this->markets_by_id, 'symbol');
            $symbol = $this->safe_string($market, 'symbol');
            $order = array_merge($order, array( 'symbol' => $symbol ));
            $ordersWithSymbols[] = $order;
        }
        return $this->parse_orders($ordersWithSymbols, null, $since, $limit);
    }

    public function parse_order($order, $market = null) {
        $symbol = $this->safe_string($order, 'symbol', '');
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        $alpacaStatus = $this->safe_string($order, 'status');
        $status = 'open';
        if ($alpacaStatus === 'filled') {
            $status = 'closed';
        } else if ($alpacaStatus === 'canceled') {
            $status = 'canceled';
        } else if ($alpacaStatus === 'expired') {
            $status = 'expired';
        }
        return $this->safeOrder2 (array(
            'id' => $this->safe_string($order, 'id'),
            'clientOrderId' => $this->safe_string($order, 'client_order_id'),
            'timestamp' => $this->milliseconds(),
            'datetime' => $this->safe_string($order, 'submitted_at'),
            'lastTradeTimeStamp' => null,
            'status' => $status,
            'symbol' => $symbol,
            'type' => $this->safe_string($order, 'order_type'),
            'timeInForce' => $this->safe_string($order, 'time_in_force'),
            'side' => $this->safe_string($order, 'side'),
            'price' => $this->safe_number($order, 'limit_price'),
            'average' => $this->safe_number($order, 'filled_avg_price'),
            'amount' => $this->safe_number($order, 'qty'),
            'filled' => $this->safe_number($order, 'filled_qty'),
            'remaining' => null,
            'cost' => null,
            'trades' => null,
            'fee' => array(
                'currency' => null,
                'cost' => null,
                'rate' => null,
            ),
            'info' => $order,
        ), $market);
    }

    public function parse_trade($trade, $market = null) {
        $symbol = $this->safe_string($trade, 'symbol', '');
        if ($market !== null) {
            $symbol = $market['symbol'];
        }
        $timestamp = $this->milliseconds(); // parseDate ($this->safe_string(quote, 't'));
        $alpacaSide = $this->safe_string($trade, 'tks');
        $side = null;
        if ($alpacaSide === 'B') {
            $side = 'buy';
        } else if ($alpacaSide === 'S') {
            $side = 'sell';
        }
        $priceString = $this->safe_string($trade, 'p');
        $amountString = $this->safe_string($trade, 's');
        $price = $this->parse_number($priceString);
        $amount = $this->parse_number($amountString);
        $cost = $this->parse_number(Precise::string_mul($priceString, $amountString));
        return array(
            'info' => $trade,
            'id' => $this->safe_string($trade, 'i'),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => null,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => 'taker',
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => array(
                'cost' => null,
                'currency' => null,
                'rate' => null,
            ),
        );
    }

    public function parse_ticker($ticker, $market = null) {
        $symbol = $market['symbol'];
        $timestamp = $this->milliseconds(); // parseDate ($this->safe_string(quote, 't'));
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'info' => $ticker,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => null,
            'low' => null,
            'bid' => $this->safe_number($ticker, 'bp'),
            'bidVolume' => $this->safe_number($ticker, 'bs'),
            'ask' => $this->safe_number($ticker, 'ap'),
            'askVolume' => $this->safe_number($ticker, 'as'),
            'vwap' => null,
            'open' => null,
            'close' => null,
            'last' => null,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => null,
            'quoteVolume' => null,
        ), $market);
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $versions = $this->safe_value($this->options, 'versions');
        $version = $this->safe_string($versions, $api);
        $endpoint = '/' . $this->implode_params($path, $params);
        $url = $this->implode_params($this->urls['api'][$api], array( 'version' => $version ));
        $headers = ($headers !== null) ? $headers : array();
        if (($api === 'private') || ($api === 'cryptoPrivate')) {
            $headers['APCA-API-KEY-ID'] = $this->apiKey;
            $headers['APCA-API-SECRET-KEY'] = $this->secret;
        }
        $query = $this->omit($params, $this->extract_params($path));
        if ($query) {
            if (($method === 'GET') || ($method === 'DELETE')) {
                $endpoint .= '?' . $this->urlencode($query);
            } else {
                $body = $this->json($query);
                $headers['Content-Type'] = 'application/json';
            }
        }
        $url = $url . $endpoint;
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function handle_errors($code, $reason, $url, $method, $headers, $body, $response, $requestHeaders, $requestBody) {
        if ($response === null) {
            return; // default error handler
        }
        // {
        //     "code" => 40110000,
        //     "message" => "request is not authorized"
        // }
        $message = $this->safe_value($response, 'message', null);
        if ($message !== null) {
            $feedback = $this->id . ' ' . $body;
            $this->throw_exactly_matched_exception($this->exceptions['exact'], $message, $feedback);
            $this->throw_broadly_matched_exception($this->exceptions['broad'], $message, $feedback);
            throw new ExchangeError($feedback); // unknown $message
        }
    }
}
